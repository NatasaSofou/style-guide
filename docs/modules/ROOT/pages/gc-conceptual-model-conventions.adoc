=== Conceptual model conventions (UML)

[[sec:cmc-r1]]
==== UML as a single source of truth

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* UML as a single source of truth

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R1

|*Statement*

The UML conceptual model should be used as the single source of truth.
|===

*Description*

By applying this principle, we can achieve consistency among all derived artefacts.

This implies:

* Standard representation of the UML such as XMI or EAP database
* Existence of a well-defined set of rules and conventions to transform UML model into other artefacts, which can be executed,
as much as possible automatically, by a dedicated software tool or toolchain [xref:gc-conceptual-model-conventions.adoc#sec:cmc-r2[CMC-R2]]

It is recommended that recent versions of the UML (v2.5+) and XMI (v2.5+) specifications are used [xref:references.adoc#ref:27[27]].


[[sec:cmc-r2]]
==== Fixed UML interpretation

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Fixed UML interpretation

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R2

|*Statement:*

Using UML as a graphical language to encode a data specification according to the reuse guidelines requires defining a set
of pre-established conventions on the UML notation to reach a fixed interpretation.

|===

*Description:*

The interpretation of UML as a logical structure, including OWL, was and still is an active research topic. But even the
OMG Ontology Definition Metamodel [xref:references.adoc#ref:28[28]] does not address the notion of reuse. The goal of using
UML is to provide for the SEMIC semantic data specifications a standard graphical notation which many are familiar with.
Therefore, the graphical notation should facilitate the understanding of the data specification. The UML notation should
match the semantics that are to be expressed in the data specification (the ontology, data shapes and human-readable documentation).

The UML is the single source of truth [xref:gc-conceptual-model-conventions.adoc#sec:cmc-r1[CMC-R1]]. Using the conventions
and associated interpretation expressed in this rule, other artefacts are derived from the UML. The benefit of defining such
a precise set of mapping rules is that it allows for:

* Implementing tools to transform UML into derivative artefacts, thus enabling UML as the single source of truth.
* Implementing tools for formal checking against the established conventions (interpretation), thus enforcing correctness,
conformance and consistency.

These rules will increase the coherency of the UML diagrams across projects and organisations.

Within SEMIC, the interpretation is implemented by the SEMIC toolchain [xref:references.adoc#ref:15[15]]. [??? - should we add a ref?]

The table below provides recommended interpretations of UML elements in OWL and SHACL.
These interpretations can be considered high-level mapping rules implementable into transformation tools that generate
OWL ontology and, respectively, SHACL constraints from the UML conceptual model.

[%autowidth]
|===
|{set:cellbgcolor: none} *UML model element*|*OWL ontology element*|*SHACL data shape element*
|*Class*|OWL Class|SHACL Node Shape
|*Abstract class*||SHACL Node Shape with a SPARQL constraint that selects all instances of this class
|*Attribute*|OWL datatype or object property, based on their type.|Property constraint, within the SHACL Node Shape corresponding
to the source UML class (but the constraints are mentioned below on type and multiplicity)
|*Attribute type*||Property constraint, within the SHACL Node Shape corresponding to the UML class, indicating the range
class or datatype.
|*Attribute multiplicity*||Property constraint(s), within the SHACL Node
|*Association (target/source role names)*|Object property declaration axiom for the target (or source, or both) end of
the association.|
|*Association source*|Optional domain declaration (data shape constraints shall be preferred).|Property constraint, within
the SHACL Node Shape corresponding to the source UML class (but the constraints are mentioned below on target and multiplicity)
|*Association target*|Optional property range declaration (data shape constraints shall be preferred).|Property constraint,
within the SHACL Node Shape corresponding to the source UML class, indicating the range class
|*Association multiplicity*||Property constraints, within the SHACL Node Shape corresponding to the source UML class, indicating
the minimum and/or maximum or exact cardinality (similar to Attribute multiplicity).
|*Association symmetry*||SPARQL constraint, within the SHACL Node Shape, corresponding to the UML constraint, within the class,
which selects instances connected by the object property in a reciprocal manner.
|*Association inverse (for bidirectional associations only)*|Two object property declaration axioms, one for the target and
the second for the source end of the association, and a declaration that the two properties stand in an inverse relationship
to one another.|
|*Dependency*|Object property declaration axiom for the target end of the association.|
|*Dependency source*||Property constraint, within the SHACL Node Shape corresponding to the source UML class (but the constraints
are mentioned below on target and multiplicity)
|*Dependency target*||Property constraints, within the SHACL Node Shape corresponding to the source UML class, indicating
(a) the range class is skos:Concept and (b) the value is skos:inScheme the target name (expected an enumeration).
|*Dependency multiplicity*||Property constraints within the SHACL
|*Class generalisation*|Subclass axiom between the classes corresponding to the UML classes. |
|*Property generalisation*|Sub-property axiom for the generalisation between UML associations and dependencies.|
|===

****
Examples:

The UML interpretation applied by the SEMIC toolchain is described in [xref:references.adoc#ref:29[29]]. To assist the editor
while data modelling to choose the best representation, a test suite is available covering all modelling patterns.

The SEMIC toolchain shares the same interpretation as the OSLO toolchain [xref:references.adoc#ref:17[17]].

In the context of eProcurement ontology, a toolchain has been developed to transform and validate UML models. Such tools
are based on two documents: UML convention specifications [xref:references.adoc#ref:30[30]] and UML transformation specifications
[xref:references.adoc#ref:31[31]].
****

[[sec:cmc-r3]]
==== On element names and URIs

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* On element names and URIs

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R3

|*Statement:*

All UML element names should be fit for URI generation with clear namespace organisation.
|===

*Description:*

This convention aims at ensuring that URIs can be generated from UML element names and shall be treated as an extension to
the terminology style conventions [xref general vocabulary naming style].

The element names are intended as human-readable denominations (called labels) and as machine-readable denominations
(called identifiers).

This means that the element names

* serve as the primary source for generating URIs [xref:references.adoc#ref:32[32]] to ensure unambiguous machine-readable
reference to a formal construct.
* serve as the primary source for generating labels to ensure human readers' comprehension
* follow an organisation of namespaces

Thus, in the UML model, the Element names must conform to RDF [xref:references.adoc#ref:33[33]] and XML [xref:references.adoc#ref:34[34]]
format specifications. Both languages effectively require that terms begin with an upper or lower case letter from the ASCII
character set or an underscore (_). This tight restriction means that, for example, terms may not begin with a number, hyphen
or accented character [xref:references.adoc#ref:35[35]]. Although underscores are permitted, they are discouraged as they may be,
in some cases, misread as spaces. A formal definition of these restrictions is given in the XML specification document
[xref:references.adoc#ref:34[34]].

Note that, when the UML element name cannot be used to effectively denominate and identify the concept then, UML Element Tags
may be used to express explicitly URIs, labels, notes and other types of annotations
[xref:gc-conceptual-model-conventions.adoc#sec:cmc-r6[CMC-R6]].


****
*Examples:*

The class Address in Core Location has several properties. All the properties have a displayed name (e.g. “addressArea”) with the UML class diagram and associated UML Tags, such as a label for the HTML specification (“address area”), definition, usage note and the related URI.

image::cmc-r3.png[]
****


[[sec:cmc-r4]]
==== Case sensitivity and charset

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Case sensitivity and charset

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R4

|*Statement:*

All UML element names are case sensitive and shall follow the CamelCase convention.
|===

*Description:*

The names begin with an upper or lower case letter (A–Z, a–z) for all terms in the model. Digits (0–9) are allowed in the
subsequent character positions.

[xref:references.adoc#ref:26[26]] _resolve references from the original doc_ - [???]

Moreover, we can significantly improve the readability of an ontology if we use consistent capitalisation for concept names;
therefore, UML element names shall be CamelCased.

The names of

* UML Classes and Datatypes shall start with an upper-case letter,
* UML Enumerations and Packages shall start with a lower-case letter,
* UML Attributes shall start with a lower-case letter,
* UML Connectors (including Target Roles and Source Roles) shall start with a lower-case letter

[xref:references.adoc#ref:36[36],
xref:references.adoc#ref:37[37]]

****
*Examples:*

In the image below, there are two classes from Core Location with the related properties and a relation between them.
The name of the classes are in UpperCamelCase, the name of the properties are in lowerCamelCase and the relation (adminUnit)
is in lowerCamelCase.

image::cmc-r4.png[]
****


[[sec:cmc-r5]]
==== Namespaces and prefixes in element names

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Namespaces and prefixes in element names

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R5

|*Statement:*

Element names shall be organised by namespaces. Namespaces may be indicated through prefixes delimited by colon (:)
character, forming qualified names.
|===

*Description:*
To enable the reuse of names defined in other models and the reuse of unique references for names that support easy identification,
namespace management must be considered. We adopt the XML and RDF approach to defining and managing namespaces
[xref:references.adoc#ref:38[38]].

A namespace is a set of symbols that are used to organise objects of various kinds so that these objects may be referred
to by name and uniquely identifiable [xref:references.adoc#ref:39[39]].

A qualified name denotes the URI, which is composed of concatenating the expanded prefix with the local segment
[xref:references.adoc#ref:40[40]]. A qualified name is a name subject to namespace interpretation [xref:references.adoc#ref:38[38]]. Syntactically,
they are either prefixed names or unprefixed names. A binding declaration shall be maintained, which binds prefixes to
namespace URIs and a default namespace applicable to unprefixed element names.

As the element name is the primary source for deriving URIs, a base URI and a local segment are necessary. The element
name prefix, before the colon, plays the role of namespace name indicating which base URI shall be used, while the element
name, after the colon, is the local segment. See [xref:references.adoc#ref:38[38]] for more info.

In case the editor decides to omit to specify a prefix in the element name when a URI generation logic is devised, an implicit
prefix can be assumed by default. The qualified names may be structured as follows:

* prefix:localSegment
* :localSegment
* localSegment

****
*Examples:*

When `dcat` a namespace name is declared as bound to base URI `http://www.w3.org/ns/dcat#`, then then `dcat:Catalog` is the
qualified name  from which the `http://www.w3.org/ns/dcat#Catalog` URI is interpreted.

When `cv` (short for Core Vocabularies) namespace name is declared bound to base URI `http://data.europa.eu/m8g/`, then
`cv:adminUnit` is the qualified name from which the `http://data.europa.eu/m8g/adminUnit` URI is generated.
****


[[sec:cmc-r6]]
==== Rich annotations through tags

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Rich annotations through tags

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R6

|*Statement:*

Tags can be conveniently used for annotating the elements.
|===

*Description:*

UML Element tags are key-value pairs that are associated with a UML Element (class, attribute, connector, etc. ). The tags
can be used as an extension mechanism to the UML language. They can be used to provide information that is not expressible
anywhere else on a UML Element.

For example, in this style guide, we recommend that the UML Element name shall be used to derive both the concept URI and
the concept preferred label. However, if the model editor chooses to use the UML Element name for deriving the concept label
alone, then the URI needs to be specified elsewhere. This is one example of how the UML tags can be used: simply specify a
new tag, “uri”, and provide the concept URI as a value (see figure below).

Another example where tags came in handy is the provisioning of notes of various types. According to the UML standard, UML
elements have only one general description. We recommend using this description solely for definitions. Yet the scope notes,
examples, alternative labels, and any other annotations can be provisioned through the UML tagging mechanism (see figure below).

****
*Examples:*

image::cmc-r6.png[]
****


[[sec:cmc-r7]]
==== Explicit depiction of external dependencies

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Explicit depiction of external dependencies

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R7

|*Statement:*
The UML diagrams should depict how the developed model relates to external (reused) models.
|===

*Description:*

UML does not support an import mechanism comparable to the one specified in OWL. Yet, the reuse of models is a highly encouraged
practice. To accommodate such practice, the reused elements shall be created as in the original model and depicted in diagrams.

The external elements shall be clearly marked. The easiest way to do so is by providing  a namespace prefix. The original
meaning shall be preserved without changes to the labels, concept definitions or URIs.

Reused classes shall be depicted in the UML diagrams. Reused properties shall be depicted in diagrams as connectors and
attributes. It is not necessary to depict unused classes or properties [xref:references.adoc#ref:41[41]].

****
*Examples:*

In the example below, a Core Vocabulary Person includes concepts from another vocabulary (FOAF); thus the two classes Person and
Agent have the “foaf” namespace prefix specified in front.

image::cmc-r7.png[]
****


[[sec:cmc-r8]]
==== Class inheritance

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Class inheritance

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R8

|*Statement:*

Make sure that the attributes and associations of a superclass apply to all its subclasses.
|===

*Description:*

This is a general modelling principle that should be respected, yet when it comes to reusing, such a requirement is often
overlooked. This means that the model editor shall carefully analyse the reused model as a whole and how it is integrated
with their own model.

****
*Examples:*

In Core Public Organization, the class Public Organisation is a subclass of org:Organization from the Organization Ontology,
and different properties/relations have been inherited such as hasSubOrganization, hasMember, hasUnit.

image::cmc-r8.png[]
****

+[xref:references.adoc#ref:42[42]] [???] should we change square bracktes?


[[sec:cmc-r9]]
==== Abstract classes

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Abstract classes

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R9

|*Statement:*

Classes that are not intended for instantiation can be marked as abstract.
|===

*Description:*

When a (super-)class is created for capturing a level of abstraction in the domain knowledge, it may not always be suitable
for instantiation. Editors may choose to mark such classes as abstract and to indicate that their subclasses shall be used in
practice. In UML, this can be done via << abstract >> stereotype.

Doing so has no impact on the OWL [xref:references.adoc#ref:43[43]] representation of the model (as this cannot be expressed in OWL).
However, SHACL data shapes [xref:references.adoc#ref:44[44]] can be generated to express that no instances of this class shall
not occur in the data. [xref:references.adoc#ref:45[45], xref:references.adoc#ref:46[46]]

****
*Examples:*

Both OSLO [xref:references.adoc#ref:17[17]] and ePO [xref:references.adoc#ref:47[47]] toolchains support such stereotypes.
****


[[sec:cmc-r10]]
==== Attribute specifications

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Attribute specifications

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R10

|*Statement:*

UML Attributes shall be used to define properties taking simple data type values. An attribute declaration should specify
its datatype and multiplicity whenever possible [xref:gc-conceptual-model-conventions.adoc#sec:cmc-r11[CMC-R11]].
|===

*Description:*

It is recommended that atomic types are used as attribute types and avoid using another class as the attribute type. Instead,
those should be expressed as relationships (represented by Association connectors) between the two classes
[xref:gc-conceptual-model-conventions.adoc#sec:cmc-r12[CMC-R12]].

High preference shall be given to using OWL 2 compliant XSD and RDF standard datatypes. Standard UML data types may be used
with interpretation in the Table below. Custom datatypes shall be avoided when possible. [ref]. [???] - what ref?

|===
|*UML*|*XSD*
|Boolean|xsd:boolean
|Float|xsd:float
|Integer|xsd:integer
|Character, String|xsd:string / rdf:langString
|Short|xsd:short
|Long|xsd:long
|Decimal|xsd:decimal
|Date|xsd:date
|DateTime|xsd:dateTime
|===

Properties whose values come from a controlled vocabulary or authority table and constitute a special case because two
modelling practices are recognised here: as attributes with type “Code”, and as dependency relations pointing to a UML Enumeration
named after the controlled list.

In the first case, the attribute type “Code” shall be mapped to the skos:Concept class. The advantage of this approach is
the compactness of the diagrams, as fewer boxes appear in them.  The disadvantage is the omission to specify precisely which
list the property values are restricted to. Arguably, the controlled list can be provided via the additional UML Tags
[xref UML tags rule], but that value will not be visible in the diagrams.

In the second case, the property is modelled not as an attribute but by using a UML Dependency connector between the Class
and the Enumeration representing the controlled list, oriented from the class towards the enumeration. It denotes that the
OWL class has an owl:ObjectProperty whose range is of type skos:Concept and is limited to values of the specified controlled
vocabulary. The connector must have a "Source->Target" direction. No other directions are acceptable, and a valid target
role name and multiplicity shall be provided [xref controlled list enumeration rule].

Finally, we emphasise that UML Connectors are reserved for the object properties only. Hence, none shall be established
between a UML class element and a UML Datatype element. [xref:references.adoc#ref:48[48], xref:references.adoc#ref:49[49],
xref:references.adoc#ref:50[50], xref:references.adoc#ref:51[51]]

****
*Examples:*

We exemplify the two approaches to specifying attribute data types described above. In CCCEV specification, the “Requirement”
class attributes use loose UML and other data types: String, Literal, and Code. No precise definition of what they mean is
provided. The attributes of the Requirement class are left underspecified and with generic data types: the “description”
attribute is a generic String, while the “type” attribute is of Code (without explicitly indicating what this data type means).
It is also not clear what would be the difference between Literal and String, eventually one may gain intuition from the
attribute name.

image::cmc-r10-1.png[]

The same class is reused in ePO ontology. The `cccev:Requirement` attributes use explicitly standard data types and cardinalities.
And the “type” attribute, indicated in the original specification, was converted to a dependency connector because it is using
a non-atomic data type, but a controlled list of `skos:Concept`(s).

image::cmc-r10-2.png[]
****


[[sec:cmc-r11]]
==== Multiplicity of attributes and connectors

|===
|{set:cellbgcolor: #a8c6f7}
 *Title:* Multiplicity of attributes and connectors

|{set:cellbgcolor: #f5f8fc}
*Acronym*: CMC-R11

|*Statement:*

The multiplicity of connectors and class attributes should be specified, indicating the minimum and maximum cardinality.
The cardinality shall be as permissive as possible in Core Vocabularies and as restrictive as possible in Application Profiles.
|===

*Description:*

If the UML model is developed to represent a Core Vocabulary, then the property cardinality (both UML Attributes and UML
Association) shall be as permissive as possible, for example, [0..*], meaning any occurrence is allowed.

If a structural feature (attribute or association) is not relevant for the domain or the applications, instead of setting
a lower limit of multiplicity to 0, simply remove it from the model [xref:references.adoc#ref:52[52]].

However, in the UML models representing Application Profiles, special attention shall be given to the multiplicity, reducing
variation in the instance data to a minimum. And if a property (attribute or connector) is mandatory in the data, then its
minimum cardinality shall be set to 1, for example [1..*] [xref:references.adoc#ref:49[49]].

A good practice is to always indicate cardinality. It may be left unspecified, but this is not recommended. When in doubt,
it is recommended to fall back on the implicit assumption of [0 .. *]. Not to be confused with the default cardinality assumed
in tools. For example, Enterprise Architect by default assumes [1..1] cardinality for attributes and omits to display it; and a
similar default assumption exists in XML/XSD.

Notation for multiple cardinality can be either with ‘*’ or ‘n’. In principle using either notation is fine, however, it is
recommended to use only one of those notations within a given data specification consistently, if possible, to enhance readability.
It is worth highlighting this, as some UML tools, by default, might use a different notation for multiple cardinality depending
on whether it is specifying the cardinality of attributes vs. that of connectors. The UML processing tools should be implemented
so as to handle either of those notations, as their meaning is identical.

Unless, well explained, no rigid constraints shall be imposed on attributes and associations. In other words, if specified,
the cardinality shall be the most permissive, where possible [xref:references.adoc#ref:52[52]].

Limit the constraints to business rules, do not add technical constraints to the model [xref:references.adoc#ref:53[53]].

If an attribute or an association from a reused vocabulary is not relevant, do not set the lower limit of multiplicity to 0,
but simply omit it in the model [xref:references.adoc#ref:52[52]].

****
*Examples:*

All Core Vocabularies have set a permissive cardinality [0..*], for example, all the properties of Public Organisation, on the left,
have multiplicity [0..*] while the same Public Organisation, in blue on right, reused in CPSV-AP has mandatory properties:

image::cmc-r11-1.png[]
image::cmc-r11-2.png[]
****


[[sec:cmc-r12]]
==== Connector specification


[[sec:cmc-r13]]
==== All elements are "public"


[[sec:cmc-r14]]
==== Controlled lists as enumerations


[[sec:cmc-r15]]
==== Partition the model into packages


[[sec:cmc-r16]]
==== Diagram readability

